name: Windows Release Build

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      ref:
        description: Git ref to build (branch, tag, or commit SHA)
        required: false
        default: main
      publish_release:
        description: Override and publish GitHub release for this run
        required: false
        default: "false"
      release_channel:
        description: Publish channel (stable or prerelease)
        required: false
        default: stable
      release_tag:
        description: Tag name to publish (e.g. v0.10.5). Leave empty to skip release publishing.
        required: false
        default: ""

permissions:
  id-token: write
  contents: write

jobs:
  build-windows:
    runs-on: windows-latest
    env:
      TEMURIN_WIN_X64_ZIP_URL: ${{ vars.TEMURIN_WIN_X64_ZIP_URL }}
      TEMURIN_WIN_X64_SHA256: ${{ vars.TEMURIN_WIN_X64_SHA256 }}
      JDTLS_DIST_URL: ${{ vars.JDTLS_DIST_URL }}
      JDTLS_DIST_SHA256: ${{ vars.JDTLS_DIST_SHA256 }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Setup Java (for bridge builds)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: gradle

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Restore Rust build cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri -> target

      - name: Restore resource archive cache
        uses: actions/cache@v4
        with:
          path: |
            .cache/temurin
            .cache/jdtls
          key: windows-resources-${{ env.TEMURIN_WIN_X64_SHA256 }}-${{ env.JDTLS_DIST_SHA256 }}

      - name: Validate required variables
        shell: pwsh
        run: |
          $required = @(
            "TEMURIN_WIN_X64_ZIP_URL",
            "TEMURIN_WIN_X64_SHA256",
            "JDTLS_DIST_URL",
            "JDTLS_DIST_SHA256"
          )
          foreach ($name in $required) {
            $value = (Get-Item "env:$name").Value
            if ([string]::IsNullOrWhiteSpace($value)) {
              throw "Missing required Actions variable: $name"
            }
          }

      - name: Install npm dependencies
        run: npm ci

      - name: Build Java parser bridge
        shell: pwsh
        run: |
          Push-Location java-parser
          gradle copyBridgeJar --no-daemon --rerun-tasks
          Pop-Location

      - name: Build JShell bridge
        shell: pwsh
        run: |
          Push-Location jshell-bridge
          gradle copyBridgeJar --no-daemon --rerun-tasks
          Pop-Location

      - name: Stop Gradle daemons
        shell: pwsh
        run: gradle --stop

      - name: Prepare bundled JDK and JDTLS resources
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Write-Host "[resources] Preparing bundled JDK and JDTLS resources..."

          New-Item -ItemType Directory -Force -Path ".cache/temurin" | Out-Null
          New-Item -ItemType Directory -Force -Path ".cache/jdtls" | Out-Null

          $temurinArchive = ".cache/temurin/temurin-win-x64.zip"
          if (!(Test-Path $temurinArchive)) {
            Write-Host "[resources] Temurin archive cache miss; downloading from URL."
            Invoke-WebRequest -Uri "$env:TEMURIN_WIN_X64_ZIP_URL" -OutFile $temurinArchive
          } else {
            Write-Host "[resources] Temurin archive cache hit: $temurinArchive"
          }
          $temurinHash = (Get-FileHash $temurinArchive -Algorithm SHA256).Hash.ToLower()
          if ($temurinHash -ne "$env:TEMURIN_WIN_X64_SHA256".ToLower()) {
            throw "Temurin SHA256 mismatch: expected $env:TEMURIN_WIN_X64_SHA256, got $temurinHash"
          }
          Write-Host "[resources] Temurin SHA256 verified."

          $jdtlsArchive = ".cache/jdtls/jdtls.tar.gz"
          if (!(Test-Path $jdtlsArchive)) {
            Write-Host "[resources] JDTLS archive cache miss; downloading from URL."
            Invoke-WebRequest -Uri "$env:JDTLS_DIST_URL" -OutFile $jdtlsArchive
          } else {
            Write-Host "[resources] JDTLS archive cache hit: $jdtlsArchive"
          }
          $jdtlsHash = (Get-FileHash $jdtlsArchive -Algorithm SHA256).Hash.ToLower()
          if ($jdtlsHash -ne "$env:JDTLS_DIST_SHA256".ToLower()) {
            throw "JDTLS SHA256 mismatch: expected $env:JDTLS_DIST_SHA256, got $jdtlsHash"
          }
          Write-Host "[resources] JDTLS SHA256 verified."

          $jdkTarget = "resources/jdk/win-x64"
          Write-Host "[resources] Extracting JDK into $jdkTarget"
          if (Test-Path $jdkTarget) { Remove-Item -Recurse -Force $jdkTarget }
          New-Item -ItemType Directory -Force -Path $jdkTarget | Out-Null
          $jdkExtract = ".cache/temurin/extracted"
          if (Test-Path $jdkExtract) { Remove-Item -Recurse -Force $jdkExtract }
          Expand-Archive -Path $temurinArchive -DestinationPath $jdkExtract -Force
          $jdkRoot = Get-ChildItem -Path $jdkExtract -Directory | Select-Object -First 1
          if ($null -eq $jdkRoot) { throw "Could not find extracted JDK directory" }
          Copy-Item -Path (Join-Path $jdkRoot.FullName "*") -Destination $jdkTarget -Recurse -Force
          Write-Host "[resources] JDK extracted successfully."

          $jdtlsTarget = "resources/jdtls"
          Write-Host "[resources] Extracting JDTLS into $jdtlsTarget"
          if (Test-Path $jdtlsTarget) { Remove-Item -Recurse -Force $jdtlsTarget }
          New-Item -ItemType Directory -Force -Path $jdtlsTarget | Out-Null
          tar -xzf $jdtlsArchive -C $jdtlsTarget
          Write-Host "[resources] JDTLS extracted successfully."

          foreach ($requiredDir in @("plugins", "config_win", "features")) {
            if (!(Test-Path (Join-Path $jdtlsTarget $requiredDir))) {
              throw "JDTLS archive missing expected directory: $requiredDir"
            }
            Write-Host "[resources] Verified JDTLS directory: $requiredDir"
          }
          Write-Host "[resources] Resource preparation complete."

      - name: Clean cached bundle intermediates
        shell: pwsh
        run: |
          Remove-Item -Recurse -Force "src-tauri/target/release/wix" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "src-tauri/target/release/bundle" -ErrorAction SilentlyContinue

      - name: Resolve Authenticode metadata
        id: authenticode_meta
        shell: pwsh
        run: |
          $eventName = "${{ github.event_name }}"
          $runRef = "${{ github.ref }}"
          $publishInput = "${{ github.event.inputs.publish_release }}"
          $releaseChannel = "${{ github.event.inputs.release_channel }}"

          $isTagPush =
            ($eventName -eq "push") -and
            ($runRef -like "refs/tags/v*")

          $isManualPrerelease =
            ($eventName -eq "workflow_dispatch") -and
            ($publishInput -eq "true") -and
            ($releaseChannel -eq "prerelease") -and
            (($runRef -eq "refs/heads/main") -or ($runRef -eq "refs/heads/prerelease"))

          $shouldAuthenticode = $isTagPush -or $isManualPrerelease
          "should_authenticode=$($shouldAuthenticode.ToString().ToLowerInvariant())" >> $env:GITHUB_OUTPUT
          if ($shouldAuthenticode) {
            Write-Host "Authenticode signing enabled for this run."
          } else {
            Write-Host "Authenticode signing disabled for this run (event=$eventName ref=$runRef publish_release=$publishInput release_channel=$releaseChannel)."
          }

      - name: Build Tauri binary only (Authenticode path)
        if: ${{ steps.authenticode_meta.outputs.should_authenticode == 'true' }}
        env:
          RUST_LOG: tauri_bundler=trace
          RUST_BACKTRACE: "1"
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build --ci --no-bundle --config src-tauri/tauri.windows.conf.json

      - name: Build Tauri installers (MSI, NSIS) (non-Authenticode path)
        if: ${{ steps.authenticode_meta.outputs.should_authenticode != 'true' }}
        env:
          RUST_LOG: tauri_bundler=trace
          RUST_BACKTRACE: "1"
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build --ci --bundles "msi,nsis" --config src-tauri/tauri.windows.conf.json

      - name: Azure login (OIDC)
        if: ${{ steps.authenticode_meta.outputs.should_authenticode == 'true' }}
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Authenticode sign app binaries (EXE + DLL)
        if: ${{ steps.authenticode_meta.outputs.should_authenticode == 'true' }}
        uses: azure/trusted-signing-action@v0.5.9
        with:
          endpoint: https://weu.codesigning.azure.net/
          trusted-signing-account-name: haala-artifact
          certificate-profile-name: unimozer-public-signing
          files-folder: src-tauri/target/release
          files-folder-recurse: false
          files-folder-filter: exe,dll
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      - name: Build Tauri installers (MSI, NSIS) (Authenticode path)
        if: ${{ steps.authenticode_meta.outputs.should_authenticode == 'true' }}
        env:
          RUST_LOG: tauri_bundler=trace
          RUST_BACKTRACE: "1"
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build --ci --bundles "msi,nsis" --config src-tauri/tauri.windows.conf.json

      - name: Authenticode sign Windows installers (MSI + NSIS)
        if: ${{ steps.authenticode_meta.outputs.should_authenticode == 'true' }}
        uses: azure/trusted-signing-action@v0.5.9
        with:
          endpoint: https://weu.codesigning.azure.net/
          trusted-signing-account-name: haala-artifact
          certificate-profile-name: unimozer-public-signing
          files-folder: src-tauri/target/release/bundle
          files-folder-recurse: true
          files-folder-filter: msi,exe
          file-digest: SHA256
          timestamp-rfc3161: http://timestamp.acs.microsoft.com
          timestamp-digest: SHA256

      - name: Verify Authenticode signatures
        if: ${{ steps.authenticode_meta.outputs.should_authenticode == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $signToolCommand = Get-Command signtool -ErrorAction SilentlyContinue
          if ($null -ne $signToolCommand) {
            $signtoolExe = $signToolCommand.Source
          } else {
            $kitsBinRoot = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\bin"
            if (!(Test-Path $kitsBinRoot)) {
              throw "signtool not found on PATH and Windows Kits bin directory does not exist: $kitsBinRoot"
            }

            $candidates = Get-ChildItem -Path $kitsBinRoot -Recurse -File -Filter "signtool.exe" |
              Where-Object { $_.FullName -match "\\x64\\" } |
              Sort-Object FullName -Descending

            $selected = $candidates | Select-Object -First 1
            if ($null -eq $selected) {
              $selected = Get-ChildItem -Path $kitsBinRoot -Recurse -File -Filter "signtool.exe" |
                Sort-Object FullName -Descending |
                Select-Object -First 1
            }
            if ($null -eq $selected) {
              throw "signtool.exe could not be resolved from Windows Kits path: $kitsBinRoot"
            }
            $signtoolExe = $selected.FullName
          }
          Write-Host "[signing] Using signtool: $signtoolExe"

          $msiInstallers = Get-ChildItem "src-tauri/target/release/bundle/msi" -File -Filter "*.msi"
          if ($msiInstallers.Count -eq 0) {
            throw "No MSI installers found for signature verification."
          }
          foreach ($installer in $msiInstallers) {
            & $signtoolExe verify /pa /v $installer.FullName
            if ($LASTEXITCODE -ne 0) {
              throw "signtool verification failed for $($installer.FullName)"
            }
          }

          $nsisInstallers = Get-ChildItem "src-tauri/target/release/bundle/nsis" -File -Filter "*.exe"
          if ($nsisInstallers.Count -eq 0) {
            throw "No NSIS installers found for signature verification."
          }
          foreach ($installer in $nsisInstallers) {
            & $signtoolExe verify /pa /v $installer.FullName
            if ($LASTEXITCODE -ne 0) {
              throw "signtool verification failed for $($installer.FullName)"
            }
          }

          $topLevelBinaries = @()
          if (Test-Path "src-tauri/target/release") {
            $topLevelBinaries += Get-ChildItem "src-tauri/target/release" -File -Filter "*.exe"
            $topLevelBinaries += Get-ChildItem "src-tauri/target/release" -File -Filter "*.dll"
          }
          if ($topLevelBinaries.Count -eq 0) {
            Write-Host "[signing] No top-level EXE/DLL binaries found for verification."
          } else {
            foreach ($binary in $topLevelBinaries) {
              & $signtoolExe verify /pa /v $binary.FullName
              if ($LASTEXITCODE -ne 0) {
                throw "signtool verification failed for $($binary.FullName)"
              }
            }
          }

      - name: Regenerate updater signatures after Authenticode
        if: ${{ steps.authenticode_meta.outputs.should_authenticode == 'true' }}
        shell: pwsh
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: |
          $ErrorActionPreference = "Stop"

          $nsisInstaller = Get-ChildItem "src-tauri/target/release/bundle/nsis" -File -Filter "*.exe" | Select-Object -First 1
          $msiInstaller = Get-ChildItem "src-tauri/target/release/bundle/msi" -File -Filter "*.msi" | Select-Object -First 1
          if ($null -eq $nsisInstaller) {
            throw "Could not locate NSIS installer for updater signature regeneration."
          }
          if ($null -eq $msiInstaller) {
            throw "Could not locate MSI installer for updater signature regeneration."
          }

          foreach ($file in @($nsisInstaller.FullName, $msiInstaller.FullName)) {
            $sigPath = "$file.sig"
            if (Test-Path $sigPath) {
              Remove-Item -Path $sigPath -Force
            }
            npx tauri signer sign "$file" | Out-Null
            if (!(Test-Path $sigPath)) {
              throw "Updater signature was not generated for $file"
            }
            Write-Host "[signing] Regenerated updater signature: $sigPath"
          }

      - name: Prepare release assets
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $cargoVersionLine = Get-Content "src-tauri/Cargo.toml" | Where-Object { $_ -match '^\s*version\s*=\s*"([^"]+)"' } | Select-Object -First 1
          if (-not $cargoVersionLine) {
            throw "Could not resolve app version from src-tauri/Cargo.toml"
          }
          $versionMatch = [regex]::Match($cargoVersionLine, '^\s*version\s*=\s*"([^"]+)"')
          if (-not $versionMatch.Success) {
            throw "Could not parse app version from src-tauri/Cargo.toml"
          }
          $version = $versionMatch.Groups[1].Value

          $releaseAssetDir = "release-assets"
          New-Item -ItemType Directory -Force -Path $releaseAssetDir | Out-Null

          $nsisFile = Get-ChildItem "src-tauri/target/release/bundle/nsis" -File | Where-Object {
            ($_.Name -match '\.exe$') -and (Test-Path "$($_.FullName).sig")
          } | Select-Object -First 1
          $msiFile = Get-ChildItem "src-tauri/target/release/bundle/msi" -File | Where-Object {
            ($_.Name -match '\.msi$') -and (Test-Path "$($_.FullName).sig")
          } | Select-Object -First 1

          if ($null -eq $nsisFile) { throw "NSIS bundle not found." }
          if ($null -eq $msiFile) { throw "MSI bundle not found." }

          $nsisSigPath = "$($nsisFile.FullName).sig"
          $msiSigPath = "$($msiFile.FullName).sig"
          if (!(Test-Path $nsisSigPath)) { throw "NSIS signature not found: $nsisSigPath" }
          if (!(Test-Path $msiSigPath)) { throw "MSI signature not found: $msiSigPath" }

          $nsisReleasePath = Join-Path $releaseAssetDir "UnimozerNext_${version}_x64-setup.exe"
          $msiReleasePath = Join-Path $releaseAssetDir "UnimozerNext_${version}_x64-setup.msi"
          Copy-Item -Path $nsisFile.FullName -Destination $nsisReleasePath -Force
          Copy-Item -Path $msiFile.FullName -Destination $msiReleasePath -Force
          Copy-Item -Path $nsisSigPath -Destination "$nsisReleasePath.sig" -Force
          Copy-Item -Path $msiSigPath -Destination "$msiReleasePath.sig" -Force

          # Stable website aliases (fixed names for latest/download links).
          $nsisAliasPath = Join-Path $releaseAssetDir "UnimozerNext_latest_x64-setup.exe"
          $msiAliasPath = Join-Path $releaseAssetDir "UnimozerNext_latest_x64-setup.msi"
          Copy-Item -Path $nsisReleasePath -Destination $nsisAliasPath -Force
          Copy-Item -Path $msiReleasePath -Destination $msiAliasPath -Force
          Copy-Item -Path "$nsisReleasePath.sig" -Destination "$nsisAliasPath.sig" -Force
          Copy-Item -Path "$msiReleasePath.sig" -Destination "$msiAliasPath.sig" -Force

      - name: Resolve release metadata
        id: release_meta
        shell: pwsh
        run: |
          $eventName = "${{ github.event_name }}"
          $publishInput = "${{ github.event.inputs.publish_release }}"
          $channel = "${{ github.event.inputs.release_channel }}"
          $tagInput = "${{ github.event.inputs.release_tag }}"
          $publishRelease = $false
          $tag = ""
          $isPrerelease = "false"

          if ($eventName -eq "push") {
            if ("${{ github.ref }}" -like "refs/tags/*" -and "${{ vars.PUBLISH_GH_RELEASE }}" -eq "true") {
              $publishRelease = $true
              $tag = "${{ github.ref_name }}"
            }
          } elseif ($eventName -eq "workflow_dispatch" -and $publishInput -eq "true") {
            if ($channel -eq "prerelease") {
              $publishRelease = $true
              $tag = "updater-prerelease"
              $isPrerelease = "true"
            } elseif (-not [string]::IsNullOrWhiteSpace($tagInput)) {
              $publishRelease = $true
              $tag = $tagInput
            }
          }

          "publish_release=$($publishRelease.ToString().ToLowerInvariant())" >> $env:GITHUB_OUTPUT
          "tag_name=$tag" >> $env:GITHUB_OUTPUT
          "is_prerelease=$isPrerelease" >> $env:GITHUB_OUTPUT

      - name: Generate updater manifests
        if: ${{ steps.release_meta.outputs.publish_release == 'true' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $nsisFile = Get-ChildItem "release-assets" -File -Filter "UnimozerNext_*_x64-setup.exe" | Select-Object -First 1
          $msiFile = Get-ChildItem "release-assets" -File -Filter "UnimozerNext_*_x64-setup.msi" | Select-Object -First 1
          if ($null -eq $nsisFile) { throw "Prepared NSIS release asset not found." }
          if ($null -eq $msiFile) { throw "Prepared MSI release asset not found." }

          $versionMatch = [regex]::Match($nsisFile.Name, '^UnimozerNext_(.+)_x64-setup\.exe$')
          if (-not $versionMatch.Success) {
            throw "Could not parse version from NSIS release filename: $($nsisFile.Name)"
          }
          $version = $versionMatch.Groups[1].Value
          $releaseTag = "${{ steps.release_meta.outputs.tag_name }}"
          $releaseBase = "https://github.com/${{ github.repository }}/releases/download/$releaseTag"
          $nsisSigPath = "$($nsisFile.FullName).sig"
          $msiSigPath = "$($msiFile.FullName).sig"
          if (!(Test-Path $nsisSigPath)) { throw "Prepared NSIS signature not found: $nsisSigPath" }
          if (!(Test-Path $msiSigPath)) { throw "Prepared MSI signature not found: $msiSigPath" }

          $nsisSig = (Get-Content $nsisSigPath -Raw).Trim()
          $msiSig = (Get-Content $msiSigPath -Raw).Trim()
          $nsisAssetName = [System.Uri]::EscapeDataString($nsisFile.Name)
          $msiAssetName = [System.Uri]::EscapeDataString($msiFile.Name)

          New-Item -ItemType Directory -Force -Path "updater-manifests" | Out-Null

          @{
            version = $version
            platforms = @{
              "windows-x86_64-nsis" = @{
                signature = $nsisSig
                url = "$releaseBase/$nsisAssetName"
              }
            }
          } | ConvertTo-Json -Depth 10 | Set-Content -Encoding utf8 "updater-manifests/latest-windows-x86_64-nsis.json"

          @{
            version = $version
            platforms = @{
              "windows-x86_64-msi" = @{
                signature = $msiSig
                url = "$releaseBase/$msiAssetName"
              }
            }
          } | ConvertTo-Json -Depth 10 | Set-Content -Encoding utf8 "updater-manifests/latest-windows-x86_64-msi.json"

      - name: Dump WiX debug files on failure
        if: failure()
        shell: pwsh
        run: |
          Write-Host "[debug] Listing WiX output directory..."
          if (Test-Path "src-tauri/target/release/wix") {
            Get-ChildItem -Recurse "src-tauri/target/release/wix" | Select-Object FullName, Length
          } else {
            Write-Host "[debug] No WiX directory found."
          }
          if (Test-Path "src-tauri/target/release/wix/x64/main.wxs") {
            Write-Host "[debug] First 250 lines of main.wxs:"
            Get-Content "src-tauri/target/release/wix/x64/main.wxs" -TotalCount 250
          }
          if (Test-Path "src-tauri/windows/fragments/umz-association.wxs") {
            Write-Host "[debug] Fragment used:"
            Get-Content "src-tauri/windows/fragments/umz-association.wxs"
          }

      - name: Upload installer artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-installers
          path: |
            release-assets/UnimozerNext_*_x64-setup.exe
            release-assets/UnimozerNext_*_x64-setup.exe.sig
            release-assets/UnimozerNext_*_x64-setup.msi
            release-assets/UnimozerNext_*_x64-setup.msi.sig
            updater-manifests/latest-windows-x86_64-nsis.json
            updater-manifests/latest-windows-x86_64-msi.json
          if-no-files-found: error

      - name: Publish GitHub release
        if: ${{ steps.release_meta.outputs.publish_release == 'true' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_meta.outputs.tag_name }}
          prerelease: ${{ steps.release_meta.outputs.is_prerelease == 'true' }}
          make_latest: ${{ steps.release_meta.outputs.is_prerelease != 'true' }}
          files: |
            release-assets/UnimozerNext_*_x64-setup.exe
            release-assets/UnimozerNext_*_x64-setup.exe.sig
            release-assets/UnimozerNext_*_x64-setup.msi
            release-assets/UnimozerNext_*_x64-setup.msi.sig
            updater-manifests/latest-windows-x86_64-nsis.json
            updater-manifests/latest-windows-x86_64-msi.json

      - name: Prune stale prerelease Windows assets
        if: ${{ steps.release_meta.outputs.publish_release == 'true' && steps.release_meta.outputs.tag_name == 'updater-prerelease' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("node:fs");
            const cargo = fs.readFileSync("src-tauri/Cargo.toml", "utf8");
            const versionMatch = cargo.match(/^version\s*=\s*"([^"]+)"/m);
            if (!versionMatch) {
              core.setFailed("Could not read version from src-tauri/Cargo.toml");
              return;
            }
            const version = versionMatch[1];
            const keep = new Set([
              `UnimozerNext_${version}_x64-setup.exe`,
              `UnimozerNext_${version}_x64-setup.exe.sig`,
              `UnimozerNext_${version}_x64-setup.msi`,
              `UnimozerNext_${version}_x64-setup.msi.sig`,
              "latest-windows-x86_64-nsis.json",
              "latest-windows-x86_64-msi.json"
            ]);
            const stalePattern = /^UnimozerNext_.*_x64-setup\.(exe|exe\.sig|msi|msi\.sig)$/;

            const { owner, repo } = context.repo;
            const release = await github.rest.repos.getReleaseByTag({
              owner,
              repo,
              tag: "updater-prerelease"
            });
            const assets = await github.paginate(github.rest.repos.listReleaseAssets, {
              owner,
              repo,
              release_id: release.data.id,
              per_page: 100
            });

            for (const asset of assets) {
              if (!stalePattern.test(asset.name)) continue;
              if (keep.has(asset.name)) continue;
              core.info(`Deleting stale Windows prerelease asset: ${asset.name}`);
              await github.rest.repos.deleteReleaseAsset({
                owner,
                repo,
                asset_id: asset.id
              });
            }
