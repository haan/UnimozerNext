name: Windows Release Build

on:
  push:
    tags:
      - "v*"
      - "*.*.*"
  workflow_dispatch:
    inputs:
      ref:
        description: Git ref to build (branch, tag, or commit SHA)
        required: false
        default: main
      publish_release:
        description: Override and publish GitHub release for this run
        required: false
        default: "false"
      release_channel:
        description: Publish channel (stable or prerelease)
        required: false
        default: stable
      release_tag:
        description: Tag name to publish (e.g. v0.10.5). Leave empty to skip release publishing.
        required: false
        default: ""

permissions:
  contents: write

jobs:
  build-windows:
    runs-on: windows-latest
    env:
      TEMURIN_WIN_X64_ZIP_URL: ${{ vars.TEMURIN_WIN_X64_ZIP_URL }}
      TEMURIN_WIN_X64_SHA256: ${{ vars.TEMURIN_WIN_X64_SHA256 }}
      JDTLS_DIST_URL: ${{ vars.JDTLS_DIST_URL }}
      JDTLS_DIST_SHA256: ${{ vars.JDTLS_DIST_SHA256 }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.ref || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm

      - name: Setup Java (for bridge builds)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: gradle

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Restore Rust build cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri -> target

      - name: Restore resource archive cache
        uses: actions/cache@v4
        with:
          path: |
            .cache/temurin
            .cache/jdtls
          key: windows-resources-${{ env.TEMURIN_WIN_X64_SHA256 }}-${{ env.JDTLS_DIST_SHA256 }}

      - name: Validate required variables
        shell: pwsh
        run: |
          $required = @(
            "TEMURIN_WIN_X64_ZIP_URL",
            "TEMURIN_WIN_X64_SHA256",
            "JDTLS_DIST_URL",
            "JDTLS_DIST_SHA256"
          )
          foreach ($name in $required) {
            $value = (Get-Item "env:$name").Value
            if ([string]::IsNullOrWhiteSpace($value)) {
              throw "Missing required Actions variable: $name"
            }
          }

      - name: Install npm dependencies
        run: npm ci

      - name: Build Java parser bridge
        shell: pwsh
        run: |
          Push-Location java-parser
          gradle copyBridgeJar --no-daemon --rerun-tasks
          Pop-Location

      - name: Build JShell bridge
        shell: pwsh
        run: |
          Push-Location jshell-bridge
          gradle copyBridgeJar --no-daemon --rerun-tasks
          Pop-Location

      - name: Stop Gradle daemons
        shell: pwsh
        run: gradle --stop

      - name: Prepare bundled JDK and JDTLS resources
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Write-Host "[resources] Preparing bundled JDK and JDTLS resources..."

          New-Item -ItemType Directory -Force -Path ".cache/temurin" | Out-Null
          New-Item -ItemType Directory -Force -Path ".cache/jdtls" | Out-Null

          $temurinArchive = ".cache/temurin/temurin-win-x64.zip"
          if (!(Test-Path $temurinArchive)) {
            Write-Host "[resources] Temurin archive cache miss; downloading from URL."
            Invoke-WebRequest -Uri "$env:TEMURIN_WIN_X64_ZIP_URL" -OutFile $temurinArchive
          } else {
            Write-Host "[resources] Temurin archive cache hit: $temurinArchive"
          }
          $temurinHash = (Get-FileHash $temurinArchive -Algorithm SHA256).Hash.ToLower()
          if ($temurinHash -ne "$env:TEMURIN_WIN_X64_SHA256".ToLower()) {
            throw "Temurin SHA256 mismatch: expected $env:TEMURIN_WIN_X64_SHA256, got $temurinHash"
          }
          Write-Host "[resources] Temurin SHA256 verified."

          $jdtlsArchive = ".cache/jdtls/jdtls.tar.gz"
          if (!(Test-Path $jdtlsArchive)) {
            Write-Host "[resources] JDTLS archive cache miss; downloading from URL."
            Invoke-WebRequest -Uri "$env:JDTLS_DIST_URL" -OutFile $jdtlsArchive
          } else {
            Write-Host "[resources] JDTLS archive cache hit: $jdtlsArchive"
          }
          $jdtlsHash = (Get-FileHash $jdtlsArchive -Algorithm SHA256).Hash.ToLower()
          if ($jdtlsHash -ne "$env:JDTLS_DIST_SHA256".ToLower()) {
            throw "JDTLS SHA256 mismatch: expected $env:JDTLS_DIST_SHA256, got $jdtlsHash"
          }
          Write-Host "[resources] JDTLS SHA256 verified."

          $jdkTarget = "resources/jdk/win-x64"
          Write-Host "[resources] Extracting JDK into $jdkTarget"
          if (Test-Path $jdkTarget) { Remove-Item -Recurse -Force $jdkTarget }
          New-Item -ItemType Directory -Force -Path $jdkTarget | Out-Null
          $jdkExtract = ".cache/temurin/extracted"
          if (Test-Path $jdkExtract) { Remove-Item -Recurse -Force $jdkExtract }
          Expand-Archive -Path $temurinArchive -DestinationPath $jdkExtract -Force
          $jdkRoot = Get-ChildItem -Path $jdkExtract -Directory | Select-Object -First 1
          if ($null -eq $jdkRoot) { throw "Could not find extracted JDK directory" }
          Copy-Item -Path (Join-Path $jdkRoot.FullName "*") -Destination $jdkTarget -Recurse -Force
          Write-Host "[resources] JDK extracted successfully."

          $jdtlsTarget = "resources/jdtls"
          Write-Host "[resources] Extracting JDTLS into $jdtlsTarget"
          if (Test-Path $jdtlsTarget) { Remove-Item -Recurse -Force $jdtlsTarget }
          New-Item -ItemType Directory -Force -Path $jdtlsTarget | Out-Null
          tar -xzf $jdtlsArchive -C $jdtlsTarget
          Write-Host "[resources] JDTLS extracted successfully."

          foreach ($requiredDir in @("plugins", "config_win", "features")) {
            if (!(Test-Path (Join-Path $jdtlsTarget $requiredDir))) {
              throw "JDTLS archive missing expected directory: $requiredDir"
            }
            Write-Host "[resources] Verified JDTLS directory: $requiredDir"
          }
          Write-Host "[resources] Resource preparation complete."

      - name: Clean cached bundle intermediates
        shell: pwsh
        run: |
          Remove-Item -Recurse -Force "src-tauri/target/release/wix" -ErrorAction SilentlyContinue
          Remove-Item -Recurse -Force "src-tauri/target/release/bundle" -ErrorAction SilentlyContinue

      - name: Build Tauri installers (MSI, NSIS)
        env:
          RUST_LOG: tauri_bundler=trace
          RUST_BACKTRACE: "1"
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        run: npx tauri build --ci --bundles "msi,nsis" --config src-tauri/tauri.windows.conf.json

      - name: Resolve release metadata
        id: release_meta
        if: ${{ (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') && vars.PUBLISH_GH_RELEASE == 'true') || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish_release == 'true' && (github.event.inputs.release_channel == 'prerelease' || github.event.inputs.release_tag != '')) }}
        shell: pwsh
        run: |
          $eventName = "${{ github.event_name }}"
          $channel = "${{ github.event.inputs.release_channel }}"
          $tagInput = "${{ github.event.inputs.release_tag }}"

          if ($eventName -eq "workflow_dispatch") {
            if ($channel -eq "prerelease") {
              $tag = "updater-prerelease"
              $isPrerelease = "true"
            } else {
              if ([string]::IsNullOrWhiteSpace($tagInput)) {
                throw "release_tag is required for stable channel publishing."
              }
              $tag = $tagInput
              $isPrerelease = "false"
            }
          } else {
            $tag = "${{ github.ref_name }}"
            $isPrerelease = "false"
          }

          "tag_name=$tag" >> $env:GITHUB_OUTPUT
          "is_prerelease=$isPrerelease" >> $env:GITHUB_OUTPUT

      - name: Generate updater manifests
        if: ${{ steps.release_meta.outputs.tag_name != '' }}
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $cargoVersionLine = Get-Content "src-tauri/Cargo.toml" | Where-Object { $_ -match '^version\s*=\s*"([^"]+)"' } | Select-Object -First 1
          if (-not $cargoVersionLine) {
            throw "Could not resolve app version from src-tauri/Cargo.toml"
          }
          $versionMatch = [regex]::Match($cargoVersionLine, '^version\s*=\s*"([^"]+)"')
          if (-not $versionMatch.Success) {
            throw "Could not parse app version from src-tauri/Cargo.toml"
          }
          $version = $versionMatch.Groups[1].Value
          $releaseTag = "${{ steps.release_meta.outputs.tag_name }}"
          $releaseBase = "https://github.com/${{ github.repository }}/releases/download/$releaseTag"
          $releaseAssetDir = "release-assets"
          New-Item -ItemType Directory -Force -Path $releaseAssetDir | Out-Null

          $nsisFile = Get-ChildItem "src-tauri/target/release/bundle/nsis" -File | Where-Object {
            ($_.Name -match '\.exe$') -and (Test-Path "$($_.FullName).sig")
          } | Select-Object -First 1
          $msiFile = Get-ChildItem "src-tauri/target/release/bundle/msi" -File | Where-Object {
            ($_.Name -match '\.msi$') -and (Test-Path "$($_.FullName).sig")
          } | Select-Object -First 1
          if ($null -eq $nsisFile) { throw "NSIS bundle not found." }
          if ($null -eq $msiFile) { throw "MSI bundle not found." }

          $nsisSigPath = "$($nsisFile.FullName).sig"
          $msiSigPath = "$($msiFile.FullName).sig"
          if (!(Test-Path $nsisSigPath)) { throw "NSIS signature not found: $nsisSigPath" }
          if (!(Test-Path $msiSigPath)) { throw "MSI signature not found: $msiSigPath" }

          $nsisReleaseName = "UnimozerNext_${version}_x64-setup.exe"
          $msiReleaseName = "UnimozerNext_${version}_x64-setup.msi"
          $nsisReleasePath = Join-Path $releaseAssetDir $nsisReleaseName
          $msiReleasePath = Join-Path $releaseAssetDir $msiReleaseName
          $nsisReleaseSigPath = "$nsisReleasePath.sig"
          $msiReleaseSigPath = "$msiReleasePath.sig"

          Copy-Item -Path $nsisFile.FullName -Destination $nsisReleasePath -Force
          Copy-Item -Path $msiFile.FullName -Destination $msiReleasePath -Force
          Copy-Item -Path $nsisSigPath -Destination $nsisReleaseSigPath -Force
          Copy-Item -Path $msiSigPath -Destination $msiReleaseSigPath -Force

          $nsisSig = (Get-Content $nsisSigPath -Raw).Trim()
          $msiSig = (Get-Content $msiSigPath -Raw).Trim()
          $nsisAssetName = [System.Uri]::EscapeDataString($nsisReleaseName)
          $msiAssetName = [System.Uri]::EscapeDataString($msiReleaseName)

          New-Item -ItemType Directory -Force -Path "updater-manifests" | Out-Null

          @{
            version = $version
            platforms = @{
              "windows-x86_64-nsis" = @{
                signature = $nsisSig
                url = "$releaseBase/$nsisAssetName"
              }
            }
          } | ConvertTo-Json -Depth 10 | Set-Content -Encoding utf8 "updater-manifests/latest-windows-x86_64-nsis.json"

          @{
            version = $version
            platforms = @{
              "windows-x86_64-msi" = @{
                signature = $msiSig
                url = "$releaseBase/$msiAssetName"
              }
            }
          } | ConvertTo-Json -Depth 10 | Set-Content -Encoding utf8 "updater-manifests/latest-windows-x86_64-msi.json"

      - name: Dump WiX debug files on failure
        if: failure()
        shell: pwsh
        run: |
          Write-Host "[debug] Listing WiX output directory..."
          if (Test-Path "src-tauri/target/release/wix") {
            Get-ChildItem -Recurse "src-tauri/target/release/wix" | Select-Object FullName, Length
          } else {
            Write-Host "[debug] No WiX directory found."
          }
          if (Test-Path "src-tauri/target/release/wix/x64/main.wxs") {
            Write-Host "[debug] First 250 lines of main.wxs:"
            Get-Content "src-tauri/target/release/wix/x64/main.wxs" -TotalCount 250
          }
          if (Test-Path "src-tauri/windows/fragments/umz-association.wxs") {
            Write-Host "[debug] Fragment used:"
            Get-Content "src-tauri/windows/fragments/umz-association.wxs"
          }

      - name: Upload installer artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-installers
          path: |
            release-assets/UnimozerNext_*_x64-setup.exe
            release-assets/UnimozerNext_*_x64-setup.exe.sig
            release-assets/UnimozerNext_*_x64-setup.msi
            release-assets/UnimozerNext_*_x64-setup.msi.sig
            updater-manifests/latest-windows-x86_64-nsis.json
            updater-manifests/latest-windows-x86_64-msi.json
          if-no-files-found: error

      - name: Publish GitHub release
        if: ${{ steps.release_meta.outputs.tag_name != '' }}
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_meta.outputs.tag_name }}
          prerelease: ${{ steps.release_meta.outputs.is_prerelease == 'true' }}
          make_latest: ${{ steps.release_meta.outputs.is_prerelease != 'true' }}
          files: |
            release-assets/UnimozerNext_*_x64-setup.exe
            release-assets/UnimozerNext_*_x64-setup.exe.sig
            release-assets/UnimozerNext_*_x64-setup.msi
            release-assets/UnimozerNext_*_x64-setup.msi.sig
            updater-manifests/latest-windows-x86_64-nsis.json
            updater-manifests/latest-windows-x86_64-msi.json

      - name: Prune stale prerelease Windows assets
        if: ${{ steps.release_meta.outputs.tag_name == 'updater-prerelease' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("node:fs");
            const cargo = fs.readFileSync("src-tauri/Cargo.toml", "utf8");
            const versionMatch = cargo.match(/^version\s*=\s*"([^"]+)"/m);
            if (!versionMatch) {
              core.setFailed("Could not read version from src-tauri/Cargo.toml");
              return;
            }
            const version = versionMatch[1];
            const keep = new Set([
              `UnimozerNext_${version}_x64-setup.exe`,
              `UnimozerNext_${version}_x64-setup.exe.sig`,
              `UnimozerNext_${version}_x64-setup.msi`,
              `UnimozerNext_${version}_x64-setup.msi.sig`,
              "latest-windows-x86_64-nsis.json",
              "latest-windows-x86_64-msi.json"
            ]);
            const stalePattern = /^UnimozerNext_.*_x64-setup\.(exe|exe\.sig|msi|msi\.sig)$/;

            const { owner, repo } = context.repo;
            const release = await github.rest.repos.getReleaseByTag({
              owner,
              repo,
              tag: "updater-prerelease"
            });
            const assets = await github.paginate(github.rest.repos.listReleaseAssets, {
              owner,
              repo,
              release_id: release.data.id,
              per_page: 100
            });

            for (const asset of assets) {
              if (!stalePattern.test(asset.name)) continue;
              if (keep.has(asset.name)) continue;
              core.info(`Deleting stale Windows prerelease asset: ${asset.name}`);
              await github.rest.repos.deleteReleaseAsset({
                owner,
                repo,
                asset_id: asset.id
              });
            }
