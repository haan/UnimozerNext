use serde::Serialize;
use std::{
    fs, io,
    path::{Path, PathBuf},
};
use tauri::AppHandle;
use zip::ZipArchive;

use crate::command_error::{to_command_error, CommandResult};
use crate::project_archive::{
    packed_workspace_dir, packed_workspace_session_root, prepare_fixed_workspace_dir,
    prepare_workspace_dir, scratch_workspace_root, write_packed_archive,
};
const SCRATCH_PROJECT_DIR_NAME: &str = "UnsavedProject";

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct OpenPackedProjectResponse {
    archive_path: String,
    workspace_dir: String,
    project_root: String,
    project_name: String,
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct OpenScratchProjectResponse {
    project_root: String,
    project_name: String,
}

fn read_single_top_level_project_name(
    archive: &mut ZipArchive<fs::File>,
) -> CommandResult<String> {
    let mut top_level: Option<String> = None;
    for index in 0..archive.len() {
        let entry = archive.by_index(index).map_err(to_command_error)?;
        let Some(enclosed) = entry.enclosed_name() else {
            return Err("Archive contains unsafe path entries".to_string());
        };
        let mut components = enclosed.components();
        let Some(std::path::Component::Normal(first)) = components.next() else {
            continue;
        };
        let first_name = first.to_string_lossy().to_string();
        if let Some(existing) = &top_level {
            if existing != &first_name {
                return Err("Packed project must contain exactly one top-level folder".to_string());
            }
        } else {
            top_level = Some(first_name);
        }
    }
    top_level.ok_or_else(|| "Archive has no project folder".to_string())
}

fn extract_archive_to_workspace(
    archive: &mut ZipArchive<fs::File>,
    workspace_dir: &Path,
) -> CommandResult<()> {
    for index in 0..archive.len() {
        let mut entry = archive.by_index(index).map_err(to_command_error)?;
        let Some(enclosed) = entry.enclosed_name() else {
            return Err("Archive contains unsafe path entries".to_string());
        };
        let output_path = workspace_dir.join(enclosed);
        if entry.is_dir() || entry.name().ends_with('/') {
            fs::create_dir_all(&output_path).map_err(to_command_error)?;
            continue;
        }
        if let Some(parent) = output_path.parent() {
            fs::create_dir_all(parent).map_err(to_command_error)?;
        }
        let mut output_file = fs::File::create(&output_path).map_err(to_command_error)?;
        io::copy(&mut entry, &mut output_file).map_err(to_command_error)?;
    }
    Ok(())
}

fn create_netbeans_project_impl(target_path: &Path) -> CommandResult<()> {
    if target_path.exists() {
        if !target_path.is_dir() {
            return Err("Target path is not a directory".to_string());
        }
        if target_path
            .read_dir()
            .map_err(to_command_error)?
            .next()
            .is_some()
        {
            return Err("Target folder is not empty".to_string());
        }
    } else {
        fs::create_dir_all(target_path).map_err(to_command_error)?;
    }

    let project_name = target_path
        .file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("NetBeansProject");

    let nbproject_dir = target_path.join("nbproject");
    let src_dir = target_path.join("src");
    fs::create_dir_all(&nbproject_dir).map_err(to_command_error)?;
    fs::create_dir_all(&src_dir).map_err(to_command_error)?;

    let build_xml = format!(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project name=\"{}\" default=\"default\" basedir=\".\">\n  <description>Generated by Unimozer Next.</description>\n  <import file=\"nbproject/build-impl.xml\"/>\n</project>\n",
        project_name
    );
    fs::write(target_path.join("build.xml"), build_xml).map_err(to_command_error)?;

    let project_xml = format!(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://www.netbeans.org/ns/project/1\">\n  <type>org.netbeans.modules.java.j2seproject</type>\n  <configuration>\n    <data xmlns=\"http://www.netbeans.org/ns/j2se-project/3\">\n      <name>{}</name>\n      <minimum-ant-version>1.10.0</minimum-ant-version>\n      <source-roots>\n        <root id=\"src.dir\"/>\n      </source-roots>\n      <test-roots>\n        <root id=\"test.src.dir\"/>\n      </test-roots>\n    </data>\n  </configuration>\n</project>\n",
        project_name
    );
    fs::write(nbproject_dir.join("project.xml"), project_xml).map_err(to_command_error)?;

    let project_properties = format!(
        "application.title={}\napplication.vendor=Unimozer\nbuild.dir=build\ndist.dir=dist\ndist.jar=${{dist.dir}}/${{application.title}}.jar\njavac.source=17\njavac.target=17\nmain.class=\nplatform.active=default_platform\nsrc.dir=src\ntest.src.dir=test\nmanifest.file=manifest.mf\n",
        project_name
    );
    fs::write(nbproject_dir.join("project.properties"), project_properties)
        .map_err(to_command_error)?;

    let manifest = "Manifest-Version: 1.0\n";
    fs::write(target_path.join("manifest.mf"), manifest).map_err(to_command_error)?;

    Ok(())
}

#[tauri::command]
pub fn open_packed_project(
    app: AppHandle,
    archive_path: String,
) -> CommandResult<OpenPackedProjectResponse> {
    let archive_input = PathBuf::from(&archive_path);
    if !archive_input.exists() {
        return Err("Project file not found".to_string());
    }
    if !archive_input.is_file() {
        return Err("Project file path is not a file".to_string());
    }

    let canonical_archive = fs::canonicalize(&archive_input).unwrap_or(archive_input);
    let archive_file = fs::File::open(&canonical_archive).map_err(to_command_error)?;
    let mut archive = ZipArchive::new(archive_file).map_err(to_command_error)?;
    if archive.len() == 0 {
        return Err("Project archive is empty".to_string());
    }

    let project_name = read_single_top_level_project_name(&mut archive)?;
    let workspace_base = packed_workspace_dir(&app, &canonical_archive)?;
    let workspace_dir = prepare_workspace_dir(&workspace_base)?;
    extract_archive_to_workspace(&mut archive, &workspace_dir)?;

    let project_root = workspace_dir.join(&project_name);
    if !project_root.is_dir() {
        return Err("Archive top-level project folder could not be extracted".to_string());
    }

    Ok(OpenPackedProjectResponse {
        archive_path: canonical_archive.to_string_lossy().to_string(),
        workspace_dir: workspace_dir.to_string_lossy().to_string(),
        project_root: project_root.to_string_lossy().to_string(),
        project_name,
    })
}

#[tauri::command]
pub fn reload_packed_project_in_place(
    app: AppHandle,
    archive_path: String,
    project_root: String,
) -> CommandResult<OpenPackedProjectResponse> {
    let archive_input = PathBuf::from(&archive_path);
    if !archive_input.exists() {
        return Err("Project file not found".to_string());
    }
    if !archive_input.is_file() {
        return Err("Project file path is not a file".to_string());
    }

    let canonical_archive = fs::canonicalize(&archive_input).unwrap_or(archive_input);
    let archive_file = fs::File::open(&canonical_archive).map_err(to_command_error)?;
    let mut archive = ZipArchive::new(archive_file).map_err(to_command_error)?;
    if archive.len() == 0 {
        return Err("Project archive is empty".to_string());
    }

    let project_name = read_single_top_level_project_name(&mut archive)?;
    let current_project_root = PathBuf::from(project_root);
    if !current_project_root.is_dir() {
        return Err("Current project root is invalid".to_string());
    }
    let workspace_dir = current_project_root
        .parent()
        .ok_or_else(|| "Current project workspace is invalid".to_string())?
        .to_path_buf();
    let allowed_workspace_root = packed_workspace_session_root(&app)?;
    let canonical_workspace_dir = fs::canonicalize(&workspace_dir).map_err(to_command_error)?;
    let canonical_allowed_workspace_root =
        fs::canonicalize(&allowed_workspace_root).map_err(to_command_error)?;
    if !canonical_workspace_dir.starts_with(&canonical_allowed_workspace_root) {
        return Err("Current project workspace is outside the packed session workspace".to_string());
    }
    prepare_fixed_workspace_dir(&workspace_dir)?;
    extract_archive_to_workspace(&mut archive, &workspace_dir)?;

    let next_project_root = workspace_dir.join(&project_name);
    if !next_project_root.is_dir() {
        return Err("Archive top-level project folder could not be extracted".to_string());
    }

    Ok(OpenPackedProjectResponse {
        archive_path: canonical_archive.to_string_lossy().to_string(),
        workspace_dir: workspace_dir.to_string_lossy().to_string(),
        project_root: next_project_root.to_string_lossy().to_string(),
        project_name,
    })
}

#[tauri::command]
pub fn create_scratch_project(app: AppHandle) -> CommandResult<OpenScratchProjectResponse> {
    let workspace_root = scratch_workspace_root(&app)?;
    let project_name = SCRATCH_PROJECT_DIR_NAME.to_string();
    let project_root = workspace_root.join(&project_name);
    prepare_fixed_workspace_dir(&project_root)?;
    create_netbeans_project_impl(&project_root)?;
    Ok(OpenScratchProjectResponse {
        project_root: project_root.to_string_lossy().to_string(),
        project_name,
    })
}

#[tauri::command]
pub fn save_packed_project(project_root: String, archive_path: String) -> CommandResult<()> {
    let root_path = PathBuf::from(project_root);
    let archive_path = PathBuf::from(archive_path);
    write_packed_archive(&root_path, &archive_path)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::{SystemTime, UNIX_EPOCH};
    use zip::{write::SimpleFileOptions, CompressionMethod, ZipWriter};

    fn create_temp_dir(label: &str) -> PathBuf {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("clock before unix epoch")
            .as_millis();
        let dir = std::env::temp_dir().join(format!(
            "unimozer-next-project-io-{label}-{}-{timestamp}",
            std::process::id()
        ));
        fs::create_dir_all(&dir).expect("create temp dir");
        dir
    }

    fn create_test_archive(path: &Path, entries: &[(&str, Option<&str>)]) {
        let file = fs::File::create(path).expect("create archive");
        let mut zip = ZipWriter::new(file);
        let dir_options = SimpleFileOptions::default()
            .compression_method(CompressionMethod::Stored)
            .unix_permissions(0o755);
        let file_options = SimpleFileOptions::default()
            .compression_method(CompressionMethod::Deflated)
            .unix_permissions(0o644);

        for (name, contents) in entries {
            if let Some(text) = contents {
                zip.start_file(name.replace('\\', "/"), file_options)
                    .expect("start file");
                use std::io::Write as _;
                zip.write_all(text.as_bytes()).expect("write file");
            } else {
                let mut dir_name = name.replace('\\', "/");
                if !dir_name.ends_with('/') {
                    dir_name.push('/');
                }
                zip.add_directory(dir_name, dir_options)
                    .expect("add directory");
            }
        }

        zip.finish().expect("finish archive");
    }

    #[test]
    fn create_netbeans_project_writes_required_files() {
        let temp_root = create_temp_dir("create-project");
        let project_dir = temp_root.join("DemoProject");
        create_netbeans_project_impl(&project_dir).expect("create netbeans project");

        assert!(project_dir.join("build.xml").is_file());
        assert!(project_dir.join("manifest.mf").is_file());
        assert!(project_dir.join("nbproject").join("project.xml").is_file());
        assert!(project_dir.join("nbproject").join("project.properties").is_file());
        assert!(project_dir.join("src").is_dir());

        let _ = fs::remove_dir_all(&temp_root);
    }

    #[test]
    fn create_netbeans_project_rejects_non_empty_directory() {
        let temp_root = create_temp_dir("non-empty");
        fs::write(temp_root.join("existing.txt"), "x").expect("write marker");
        let error = create_netbeans_project_impl(&temp_root).expect_err("expected non-empty error");
        assert!(error.contains("not empty"));
        let _ = fs::remove_dir_all(&temp_root);
    }

    #[test]
    fn read_single_top_level_project_name_rejects_multiple_roots() {
        let temp_root = create_temp_dir("multiple-roots");
        let archive_path = temp_root.join("sample.umz");
        create_test_archive(
            &archive_path,
            &[
                ("ProjectA/src/Main.java", Some("class Main {}")),
                ("ProjectB/src/Other.java", Some("class Other {}")),
            ],
        );

        let file = fs::File::open(&archive_path).expect("open archive");
        let mut archive = ZipArchive::new(file).expect("read archive");
        let error = read_single_top_level_project_name(&mut archive).expect_err("expected error");
        assert!(error.contains("exactly one top-level folder"));

        let _ = fs::remove_dir_all(&temp_root);
    }

    #[test]
    fn extract_archive_to_workspace_writes_files() {
        let temp_root = create_temp_dir("extract");
        let archive_path = temp_root.join("sample.umz");
        let workspace_dir = temp_root.join("workspace");
        fs::create_dir_all(&workspace_dir).expect("create workspace");
        create_test_archive(
            &archive_path,
            &[
                ("DemoProject/", None),
                ("DemoProject/src/Main.java", Some("class Main {}")),
                ("DemoProject/nbproject/project.xml", Some("<project/>")),
            ],
        );

        let file = fs::File::open(&archive_path).expect("open archive");
        let mut archive = ZipArchive::new(file).expect("read archive");
        extract_archive_to_workspace(&mut archive, &workspace_dir).expect("extract archive");

        assert!(workspace_dir.join("DemoProject").is_dir());
        assert!(workspace_dir.join("DemoProject").join("src").join("Main.java").is_file());
        assert!(
            workspace_dir
                .join("DemoProject")
                .join("nbproject")
                .join("project.xml")
                .is_file()
        );

        let _ = fs::remove_dir_all(&temp_root);
    }

    #[test]
    fn save_packed_project_writes_archive_file() {
        let temp_root = create_temp_dir("save-packed");
        let project_root = temp_root.join("DemoProject");
        fs::create_dir_all(project_root.join("src")).expect("create src");
        fs::create_dir_all(project_root.join("nbproject")).expect("create nbproject");
        fs::write(project_root.join("src").join("Main.java"), "class Main {}").expect("write java");
        fs::write(project_root.join("nbproject").join("project.xml"), "<project/>")
            .expect("write project xml");

        let archive_path = temp_root.join("Lesson1.umz");
        save_packed_project(
            project_root.to_string_lossy().to_string(),
            archive_path.to_string_lossy().to_string(),
        )
        .expect("save packed project");

        assert!(archive_path.is_file());
        let file = fs::File::open(&archive_path).expect("open archive");
        let mut archive = ZipArchive::new(file).expect("read archive");
        let mut names = Vec::new();
        for index in 0..archive.len() {
            names.push(
                archive
                    .by_index(index)
                    .expect("read archive entry")
                    .name()
                    .to_string(),
            );
        }
        assert!(names.iter().any(|name| name == "Lesson1/"));
        assert!(names.iter().any(|name| name == "Lesson1/src/Main.java"));

        let _ = fs::remove_dir_all(&temp_root);
    }

    #[test]
    fn save_packed_project_rejects_missing_project_root() {
        let temp_root = create_temp_dir("save-packed-missing");
        let missing_root = temp_root.join("DoesNotExist");
        let archive_path = temp_root.join("Lesson1.umz");

        let error = save_packed_project(
            missing_root.to_string_lossy().to_string(),
            archive_path.to_string_lossy().to_string(),
        )
        .expect_err("expected missing project root error");
        assert!(error.contains("Project root directory not found"));

        let _ = fs::remove_dir_all(&temp_root);
    }
}

